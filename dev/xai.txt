for i, patch in enumerate(all_angio_patches_np_list):
    if i in pos_patches_idxs:    
        # volume_tensor = tf.convert_to_tensor(patch, dtype=tf.float32)
        volume_tensor = tf.expand_dims(patch, axis=0)
        # Define a gradient tape to compute gradients
        with tf.GradientTape() as tape:
            tape.watch(volume_tensor)
            # Forward pass through the model
            predictions = unet(volume_tensor, training=False)  # Disable training mode
            # Compute loss
            loss = predictions[:, :, :, :, 0]  # Assuming binary segmentation (foreground class)
    
        # Compute gradients of loss with respect to volume tensor
        gradients = tape.gradient(loss, volume_tensor)
        # Compute gradients magnitude
        gradients_magnitude = tf.sqrt(tf.reduce_mean(tf.square(gradients), axis=-1))
        # Generate Grad-CAM heatmap
        heatmap = tf.nn.relu(tf.reduce_sum(gradients * volume_tensor, axis=-1))
        heatmap /= tf.reduce_max(heatmap)

        heatmap_nifti = nib.Nifti1Image(heatmap.numpy(), aff_resampled)  # Assuming identity affine matrix for simplicity
        nib.save(heatmap_nifti, f'/home/student/Documents/MDS22/heatmap_test/heatmap_{i}.nii.gz')
with open('/home/student/Documents/MDS22/heatmap_test/coords.txt', 'w') as fp:
    for coord in patch_center_coords:
        fp.write("%s\n" % str(coord))
            # img_sitk = sitk.ReadImage(os.path.join(this_out_path, 'result.nii.gz'), sitk.sitkFloat32)
            # img_sitk_array = sitk.GetArrayFromImage(img_sitk)

            # ct_patch_chunk_list, last_patch_number = get_image_array_and_give_chunk(image_array=img_sitk_array, patch_slice=64)
            # # ct_patch_chunk_list = []
            # # for result in results:
            # #     ct_patch_chunk_list.append(img_sitk_array[int(result[0]):int(result[0])+64])
                
            # first_heatmap = guided_gradcam_3d(build_model, ct_patch_chunk_list[0], 1)
            # heatmap_concat = first_heatmap

            # for i in range(1,(len(ct_patch_chunk_list)-1)):
            #     get_heatmap = guided_gradcam_3d(build_model, ct_patch_chunk_list[i], 1)
            #     heatmap_concat = np.concatenate((heatmap_concat, get_heatmap), axis=0)

            # last_heatmap = guided_gradcam_3d(build_model, ct_patch_chunk_list[-1], 1)
            # heatmap_concat  = np.concatenate((heatmap_concat, last_heatmap[last_patch_number:, :, :]), axis=0)
            # # heatmap_concat  = np.concatenate((heatmap_concat, last_heatmap[img_sitk_array.shape[0]-1:, :, :]), axis=0)
            # s_itk_image = sitk.GetImageFromArray(heatmap_concat)
            # s_itk_image.CopyInformation(img_sitk)
            # sitk.WriteImage(s_itk_image, os.path.join(this_out_path, 'xai.nii.gz'))

            def get_image_array_and_give_chunk(image_array, patch_slice):
    divide_integer = image_array.shape[0] // patch_slice
    reminder = image_array.shape[0] % patch_slice
    print('CT Volume_Shape={}'.format(image_array.shape))
    print('Devide_integer={}'.format(divide_integer))
    print('Reminder={}'.format(reminder))
    print('Total of {} + {} ={} Should ={}'.format(patch_slice*divide_integer, reminder, patch_slice*divide_integer+reminder, image_array.shape[0]))

    lastpatch_starts_from = (image_array.shape[0]) - patch_slice
    # print(lastpatch_starts_from)

    patch_list=[]
    patch_start=0
    patch_end = patch_slice
    for i in range(divide_integer):
        #print(patch_start)
        #print(patch_end)
        ct_volume = image_array[patch_start:patch_end,:,:]
        #print(ct_volume.shape)
        patch_list.append(ct_volume)
        patch_start += patch_slice
        patch_end += patch_slice

    last_slice_number_would_be=image_array.shape[0]
    # print(last_slice_number_would_be)
    last_patch_when_making_nifty=(patch_slice)-reminder
    # print(last_patch_When_making_nifty)
    Slice_will_start_from_here=last_slice_number_would_be-patch_slice
    # print(Slice_will_start_from_here)
    last_patch = image_array[Slice_will_start_from_here:,:,:]
    # last_patch.shape
    patch_list.append(last_patch)

    return patch_list, last_patch_when_making_nifty